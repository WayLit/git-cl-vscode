## Codebase Patterns
- Use `pnpm` as package manager (npm is broken on this system)
- Build with esbuild: `pnpm run build` bundles src/extension.ts → dist/extension.js
- Typecheck with: `pnpm run typecheck` (tsc --noEmit)
- Extension entry point: `src/extension.ts` with `activate()` and `deactivate()` exports
- VS Code extension manifest in `package.json` under `contributes`
- esbuild requires build approval in `.npmrc`: `onlyBuiltDependencies[]=esbuild`
- Sandbox restrictions block `.git` writes — use `dangerouslyDisableSandbox: true` for git commands
- Project root is `/home/satya/oss/git-cl-vscode/`, working directory is `.chief/prds/main`
- Data model: `ChangelistStore` (src/changelistStore.ts) for cl.json, `StashStore` (src/stashStore.ts) for cl-stashes.json
- cl.json format: `Record<string, string[]>` — changelist name → relative file paths (forward slashes)
- cl-stashes.json format: `Record<string, StashMetadata>` — uses snake_case keys for Python interop
- Use `validateChangelistName()` and `sanitizeFilePath()` from changelistStore.ts for input validation
- Git operations: `src/gitUtils.ts` wraps all git commands via `child_process.execFile` (no shell)
- All gitUtils functions take `gitRoot` as parameter — pass result of `getGitRoot()`
- `getGitStatus()` returns `Map<string, string>` with path → 2-char status code (porcelain format)
- SCM provider: `ChangelistSCMProvider` (src/scmProvider.ts) manages the Source Control sidebar tree
- SCM groups ordered: [active changelists] → Unassigned → [stashed changelists]
- Groups are rebuilt when changelist set changes; resource states updated on every refresh
- Diff on click uses custom `git-cl-head` URI scheme via `HeadContentProvider` (shows `git show HEAD:path`)
- File watchers on `.git/cl.json`, `.git/cl-stashes.json`, `.git/index` + workspace file saves trigger debounced refresh (300ms)
- `activate()` in extension.ts is async — resolves gitRoot before creating SCM provider
- File decorations: `ChangelistDecorationProvider` in scmProvider.ts provides status badge letters + colors via `FileDecorationProvider` API
- `statusToDecoration()` maps 2-char git status codes to `FileDecoration` (badge letter, tooltip, ThemeColor)
- Use `vscode.window.registerFileDecorationProvider()` — fires `onDidChangeFileDecorations(undefined)` to refresh all decorations
- Missing-file detection uses `fs.existsSync()` for files in changelists not marked as git-deleted
- `dist/` is in `.gitignore` — don't try to `git add` build output
- SCM context menu args: first arg = clicked resource, second arg = array of all selected (multi-select)
- Command palette invocations get no args — detect and show file picker fallback
- `when` clause: `scmProvider == git` for built-in Git; `scmProvider == git-cl` for ours
- `validateChangelistName()` signature matches `showInputBox({ validateInput })` — returns `string | null`
- SCM group header commands: use `scm/resourceGroup/context` menu; first arg = `SourceControlResourceGroup` (has `.id`)
- Group ID convention: `cl:<name>` for active changelists, `stash:<name>` for stashed, `unassigned` for unassigned
- SCM input box access: `scmProvider.getSourceControl().inputBox.value` — prefer over always prompting for commit messages
- Inline button ordering: `inline@1` (stage), `inline@2` (unstage), `inline@3` (commit), `inline@9` (delete)
- Context menu ordering: `1_modification@1` (stage), `1_modification@2` (unstage), `1_modification@3` (commit), `1_modification@4` (delete)

## 2026-02-19 - US-001
- What was implemented: Full VS Code extension scaffold with build tooling
- Files changed:
  - `package.json` — Extension manifest with contributes, activationEvents, engines, scripts
  - `tsconfig.json` — TypeScript config targeting ES2020 with strict mode
  - `src/extension.ts` — Extension entry point with activate/deactivate
  - `.vscode/launch.json` — F5 Extension Development Host launch config
  - `.vscode/tasks.json` — Default build task for esbuild
  - `.gitignore` — Ignores node_modules, dist, .vsix, .venv
  - `.vscodeignore` — Excludes source/dev files from packaged extension
  - `.npmrc` — pnpm build approval config for esbuild
  - `pnpm-lock.yaml` — Lock file
- **Learnings for future iterations:**
  - npm is broken on this system; use `pnpm` for all package management
  - pnpm 10.x requires explicit approval for package build scripts via `.npmrc`
  - git init and git commands need `dangerouslyDisableSandbox: true` due to sandbox restrictions on `.git/`
  - The project CWD is `.chief/prds/main` but source code goes in `/home/satya/oss/git-cl-vscode/`
  - esbuild is configured inline in `package.json` scripts (no separate config file needed)
---

## 2026-02-19 - US-002
- What was implemented: Core data model for changelist storage
  - `ChangelistStore` class — loads/saves `.git/cl.json`, enforces single-ownership of files across changelists
  - `StashStore` class — loads/saves `.git/cl-stashes.json` with full stash metadata
  - `validateChangelistName()` — alphanumeric + hyphens/underscores/dots, max 100 chars, rejects git reserved words
  - `sanitizeFilePath()` — validates relative paths, rejects traversal/absolute/unsafe chars
  - Stash conflict check: files in stashed changelists cannot be added to active changelists
  - Empty changelists omitted on save (matches Python git-cl behavior)
- Files changed:
  - `src/changelistStore.ts` — ChangelistStore class, name validation, path sanitization
  - `src/stashStore.ts` — StashStore class, stash metadata types, type guards
- **Learnings for future iterations:**
  - Data format uses snake_case keys (e.g., `stash_ref`, `source_branch`, `file_categories`) to match Python git-cl interop
  - `cl.json` is a simple `Record<string, string[]>` — changelist name → relative file paths
  - `cl-stashes.json` maps changelist name → `StashMetadata` with `stash_ref`, `stash_message`, `files`, `timestamp`, `source_branch`, `file_categories`
  - File paths in cl.json use forward slashes (git convention) regardless of OS
  - Build (`pnpm run build`) needs `dangerouslyDisableSandbox: true` due to write to `dist/`
---

## 2026-02-19 - US-003
- What was implemented: Git utility layer wrapping common git operations
  - `getGitRoot(cwd)` — returns absolute path to repository root
  - `getGitStatus(gitRoot)` — runs `git status --porcelain`, returns `Map<string, string>` (path → 2-char status)
  - `gitAdd(files, gitRoot)` — stages specified files
  - `gitReset(files, gitRoot)` — unstages files (git reset HEAD)
  - `gitCheckout(files, gitRoot)` — reverts files to HEAD
  - `gitCommit(files, message, gitRoot)` — stages and commits files with message
  - `gitDiff(files, gitRoot, options?)` — returns diff output, supports `--staged`
  - `gitStashPush(message, gitRoot, files?)` — creates stash with optional file filtering
  - `gitStashPop(ref, gitRoot)` — pops a specific stash reference
  - `gitStashList(gitRoot)` — lists stash entries with refs and messages
  - `getCurrentBranch(gitRoot)` — returns branch name or null if detached
  - `gitCheckoutBranch(name, gitRoot, base?)` — creates and switches to new branch
- Files changed:
  - `src/gitUtils.ts` — All git utility functions, uses `child_process.execFile` for safety
- **Learnings for future iterations:**
  - All git operations use `execFile` (not `exec`) to avoid shell injection
  - `git status --porcelain` format: first 2 chars are status code, char 3 is space, rest is file path
  - Renamed files appear as `R  old -> new` — parser extracts the new path
  - `git symbolic-ref --short HEAD` fails in detached HEAD state — catch and return null
  - `gitStashList` returns empty array on error (e.g., no stash entries) rather than throwing
  - Private `execGit` helper centralizes error handling with 10MB max buffer
---

## 2026-02-19 - US-004
- What was implemented: SCM Provider & Changelist Tree View
  - `ChangelistSCMProvider` class — registers `vscode.scm.createSourceControl`, manages resource groups
  - `HeadContentProvider` — `TextDocumentContentProvider` for `git-cl-head` scheme, returns `git show HEAD:path`
  - Active changelist groups: one `SourceControlResourceGroup` per changelist from cl.json
  - Unassigned group: shows git-tracked files not in any changelist or stash
  - Stashed groups: read-only, labeled with changelist name, source branch, and timestamp
  - Diff on click: clicking a file opens `vscode.diff(headUri, workingUri)` for tracked files, `vscode.open` for untracked
  - Auto-refresh: watchers on `.git/cl.json`, `.git/cl-stashes.json`, `.git/index`, plus workspace file saves
  - Debounced refresh (300ms) to avoid excessive updates
  - Group ordering maintained: active changelists → Unassigned → stashed changelists
  - Updated `extension.ts` to async `activate()` that resolves gitRoot and creates the SCM provider
- Files changed:
  - `src/scmProvider.ts` — New file: ChangelistSCMProvider, HeadContentProvider
  - `src/extension.ts` — Updated: async activate, SCM provider initialization
- **Learnings for future iterations:**
  - VS Code SCM resource groups appear in creation order — dispose and recreate all groups when the set changes to maintain ordering
  - `SourceControlResourceGroup.hideWhenEmpty` hides groups with no resource states
  - For diff, use a custom URI scheme with `TextDocumentContentProvider` rather than depending on the built-in git extension's internals
  - Untracked files (`??` status) have no HEAD version — use `vscode.open` instead of `vscode.diff`
  - `SourceControlResourceState.decorations.faded` is useful for stashed/read-only files
  - `SourceControlResourceState.decorations.strikeThrough` marks deleted files
---

## 2026-02-19 - US-005
- What was implemented: File status decorations for changelist tree items
  - `ChangelistDecorationProvider` — implements `FileDecorationProvider`, provides status badge letters (M/A/D/U/R/C/!) and theme colors
  - `statusToDecoration()` — maps 2-char git porcelain status codes to `FileDecoration` with appropriate badge and color
  - Missing-file detection: files in changelists that no longer exist on disk get a `!` badge, strikethrough, and warning icon
  - `createResourceState()` enhanced: checks `fs.existsSync()`, uses `ThemeIcon('warning')` for missing files
  - Decoration provider fires `onDidChangeFileDecorations` on every SCM refresh cycle
  - Color scheme uses VS Code standard theme colors: `gitDecoration.modifiedResourceForeground`, `.addedResourceForeground`, `.deletedResourceForeground`, `.untrackedResourceForeground`, `.conflictingResourceForeground`
- Files changed:
  - `src/scmProvider.ts` — Added ChangelistDecorationProvider, statusToDecoration, enhanced createResourceState
- **Learnings for future iterations:**
  - `FileDecorationProvider` is the standard way to add badge letters and colors to any view (Explorer, SCM, etc.)
  - `vscode.FileDecoration(badge, tooltip, color)` — badge is 1-2 chars, color is a ThemeColor
  - Fire `onDidChangeFileDecorations(undefined)` to refresh all URIs (simpler than tracking individual changes)
  - `SourceControlResourceDecorations.iconPath` accepts `ThemeIcon` — useful for warning/error indicators
  - `dist/` is gitignored — only commit source files, not build output
  - Conflict detection: UU, AA, DD, AU, UA, DU, UD status codes all indicate merge conflicts
---

## 2026-02-19 - US-006
- What was implemented: Add Files to Changelist command with context menu and command palette support
  - `git-cl.addToChangelist` command registered in command palette and context menus
  - Context menu "Add to Changelist" on built-in Git SCM files (`scmProvider == git`)
  - Context menu "Add to Changelist" on Unassigned group files (`scmProvider == git-cl && scmResourceGroup == unassigned`)
  - Multi-select support: extracts file paths from second arg (array of selected resources)
  - Command palette mode: shows QuickPick with all modified/untracked files from git status for multi-select
  - `pickChangelist()`: QuickPick with existing changelists + "Create New Changelist" option that shows InputBox
  - InputBox validates name via `validateChangelistName()` inline
  - Files silently moved between changelists (handled by `ChangelistStore.addFiles()`)
  - Tree view refreshes immediately after adding via `scmProvider.refresh()`
  - Added `getGitRoot()` getter to `ChangelistSCMProvider`
- Files changed:
  - `package.json` — Added `git-cl.addToChangelist` command + `scm/resourceState/context` menu contributions
  - `src/extension.ts` — Command handler, `resolveFilePaths()`, `pickChangelist()` helper functions
  - `src/scmProvider.ts` — Added `getGitRoot()` public getter
- **Learnings for future iterations:**
  - SCM context menu args: first arg = clicked resource, second arg = array of all selected resources (multi-select)
  - `scm/resourceState/context` menu needs separate entries for each `scmProvider` (git vs git-cl)
  - `when` clause for built-in Git SCM: `scmProvider == git`; for our SCM: `scmProvider == git-cl`
  - `validateChangelistName()` returns `string | null` — compatible with `showInputBox({ validateInput })` API
  - For command palette invocations (no args), show file picker from `getGitStatus()` with `canPickMany: true`
---

## 2026-02-19 - US-007
- What was implemented: Remove Files from Changelist command with context menu and command palette support
  - `git-cl.removeFromChangelist` command registered in command palette and context menus
  - Context menu "Remove from Changelist" on files inside active changelist groups (`scmResourceGroup =~ /^cl:/`)
  - Multi-select support: handles array of selected resources from second arg
  - Command palette mode: shows QuickPick with all files from all changelists, grouped by changelist name
  - Uses `ChangelistStore.findChangelist()` to determine which changelist each file belongs to, then `removeFiles()` to remove
  - Files return to the "Unassigned" group after removal
  - Tree view refreshes immediately after removing via `scmProvider.refresh()`
- Files changed:
  - `package.json` — Added `git-cl.removeFromChangelist` command + `scm/resourceState/context` menu entry
  - `src/extension.ts` — Command handler + `resolveFilePathsFromChangelists()` helper function
- **Learnings for future iterations:**
  - Use `scmResourceGroup =~ /^cl:/` in `when` clause to match active changelist groups (IDs are `cl:<name>`)
  - VS Code `when` clauses support regex via `=~` operator — useful for matching dynamic group IDs
  - `ChangelistStore.findChangelist(path)` looks up which changelist owns a file — useful for removal without needing group context
  - Command palette removal shows files with their changelist name as description, helping users identify which list a file belongs to
---

## 2026-02-19 - US-008
- What was implemented: Delete Changelist commands with inline button and confirmation
  - `git-cl.deleteChangelist` command — deletes a single changelist with confirmation prompt
  - `git-cl.deleteAllChangelists` command — deletes all changelists with confirmation prompt
  - Inline trash icon button on changelist group headers via `scm/resourceGroup/context` menu
  - Context menu "Delete Changelist" entry on group headers
  - Command palette flow: QuickPick to select changelist, then confirmation dialog
  - Confirmation shows file count (e.g., "3 file(s) will be moved to Unassigned")
  - `resolveChangelistName()` extracts changelist name from group ID (strips `cl:` prefix)
  - Tree view refreshes immediately after deletion
- Files changed:
  - `package.json` — Added `git-cl.deleteChangelist` + `git-cl.deleteAllChangelists` commands, `scm/resourceGroup/context` menu entries
  - `src/extension.ts` — Command handlers, `resolveChangelistName()`, `pickChangelistForDeletion()`, `deleteChangelistWithConfirmation()` helpers
- **Learnings for future iterations:**
  - `scm/resourceGroup/context` menu is for group headers (vs `scm/resourceState/context` for file items)
  - Group header context menu args: first arg = `SourceControlResourceGroup` object (has `.id` property)
  - Use `group: "inline"` in menu contribution to show icon buttons on group headers
  - `ChangelistStore.deleteChangelist(name)` returns the removed files array (useful for undo if needed later)
  - `ChangelistStore.deleteAll()` clears all in-memory data; `save()` writes empty object to disk
---

## 2026-02-19 - US-009
- What was implemented: Stage Changelist command with inline button and command palette support
  - `git-cl.stageChangelist` command — stages all tracked files in a changelist
  - Inline stage button (`+` icon) on changelist group headers via `scm/resourceGroup/context` menu
  - Context menu "Stage Changelist" entry on group headers
  - Command palette flow: QuickPick to select changelist, then stage tracked files
  - Filters to tracked files only — untracked (`??`) files are skipped (matches git-cl behavior)
  - Shows notification if changelist is empty or has no tracked files
  - Refactored `pickChangelistForDeletion()` into generic `pickChangelistForAction(action)` for reuse
- Files changed:
  - `package.json` — Added `git-cl.stageChangelist` command + inline/context menu entries
  - `src/extension.ts` — Stage command handler, `pickChangelistForAction()` generic helper
- **Learnings for future iterations:**
  - Use `group: "inline@N"` to control ordering of inline buttons on group headers (lower N = further left)
  - `pickChangelistForAction(scmProvider, action)` is a generic QuickPick helper — reuse for stage, unstage, commit, diff, etc.
  - Tracked files = files in git status that are NOT `??` (untracked); filter before staging
  - `gitAdd()` from gitUtils.ts handles the actual `git add` operation
---

## 2026-02-19 - US-010
- What was implemented: Unstage Changelist command with inline button and command palette support
  - `git-cl.unstageChangelist` command — unstages all staged files in a changelist
  - Inline unstage button (`-` icon) on changelist group headers via `scm/resourceGroup/context` menu (inline@2)
  - Context menu "Unstage Changelist" entry on group headers (1_modification@2)
  - Command palette flow: QuickPick to select changelist, then unstage staged files
  - Filters to files with staged changes only — checks first char of porcelain status (non-space, non-?)
  - Shows notification if changelist is empty or has no staged files
  - Uses `gitReset()` from gitUtils.ts to execute `git reset HEAD --`
- Files changed:
  - `package.json` — Added `git-cl.unstageChangelist` command + inline/context menu entries
  - `src/extension.ts` — Unstage command handler, imported `gitReset`
- **Learnings for future iterations:**
  - Staged files detection: in `git status --porcelain`, first char (index status) is non-space and non-`?` for staged files
  - `gitReset()` from gitUtils.ts handles `git reset HEAD --` for unstaging
  - Inline button ordering: `inline@1` (stage), `inline@2` (unstage), `inline@9` (delete) — use gaps for future insertions
  - Context menu ordering: `1_modification@1` (stage), `1_modification@2` (unstage), `1_modification@3` (delete)
---

## 2026-02-19 - US-011
- What was implemented: Commit Changelist command with inline button and command palette support
  - `git-cl.commitChangelist` command — commits all tracked files in a changelist with a message
  - Inline commit button (`check` icon) on changelist group headers via `scm/resourceGroup/context` menu (inline@3)
  - Context menu "Commit Changelist" entry on group headers (1_modification@3)
  - Command palette flow: QuickPick to select changelist, then prompt for message
  - Commit message sourcing: uses SCM input box text if present, otherwise prompts via InputBox
  - Filters to tracked files only — untracked (`??`) files are skipped
  - Shows error if no tracked files or commit fails
  - Deletes changelist after successful commit (default behavior)
  - Clears SCM input box after successful commit
  - Success notification shows count of committed files
  - Uses `gitCommit()` from gitUtils.ts which stages then commits
- Files changed:
  - `package.json` — Added `git-cl.commitChangelist` command + inline/context menu entries
  - `src/extension.ts` — Commit command handler, imported `gitCommit`
- **Learnings for future iterations:**
  - `scmProvider.getSourceControl().inputBox.value` gives access to the SCM input box text — prefer this over always prompting
  - `gitCommit()` in gitUtils.ts handles both staging and committing in one call
  - Inline button ordering updated: `inline@1` (stage), `inline@2` (unstage), `inline@3` (commit), `inline@9` (delete)
  - Context menu ordering updated: `1_modification@1` (stage), `1_modification@2` (unstage), `1_modification@3` (commit), `1_modification@4` (delete)
---

## 2026-02-19 - US-012
- What was implemented: Diff Changelist command with context menu and command palette support
  - `git-cl.diffChangelist` command — opens diff tabs for all files in a changelist
  - Context menu "Diff Changelist" entry on changelist group headers (group `2_diff@1`)
  - Command palette flow: QuickPick to select changelist, then open diffs
  - For modified/staged files: opens `vscode.diff(HEAD, workingCopy)` showing all changes
  - For untracked files: opens file directly (no HEAD version exists)
  - For deleted files: opens HEAD version read-only
  - All tabs opened with `preview: false` so they stay open
  - Works correctly for files in subdirectories (uses relative paths with forward slashes)
- Files changed:
  - `package.json` — Added `git-cl.diffChangelist` command + `scm/resourceGroup/context` menu entry
  - `src/extension.ts` — Diff command handler using existing `pickChangelistForAction()` and `resolveChangelistName()`
- **Learnings for future iterations:**
  - VS Code `vscode.diff` command opens a diff editor tab — use `{ preview: false }` to prevent tab reuse
  - For multi-file diff, open each file's diff sequentially with `await` to ensure proper tab ordering
  - Deleted files can be shown read-only via the HEAD content provider (`git-cl-head` scheme)
  - Menu group `2_diff@1` separates diff actions from modification actions (`1_modification`) in context menus
  - The `$(diff)` codicon icon is available for diff-related commands
---
