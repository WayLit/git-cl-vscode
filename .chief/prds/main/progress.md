## Codebase Patterns
- Use `pnpm` as package manager (npm is broken on this system)
- Build with esbuild: `pnpm run build` bundles src/extension.ts → dist/extension.js
- Typecheck with: `pnpm run typecheck` (tsc --noEmit)
- Extension entry point: `src/extension.ts` with `activate()` and `deactivate()` exports
- VS Code extension manifest in `package.json` under `contributes`
- esbuild requires build approval in `.npmrc`: `onlyBuiltDependencies[]=esbuild`
- Sandbox restrictions block `.git` writes — use `dangerouslyDisableSandbox: true` for git commands
- Project root is `/home/satya/oss/git-cl-vscode/`, working directory is `.chief/prds/main`
- Data model: `ChangelistStore` (src/changelistStore.ts) for cl.json, `StashStore` (src/stashStore.ts) for cl-stashes.json
- cl.json format: `Record<string, string[]>` — changelist name → relative file paths (forward slashes)
- cl-stashes.json format: `Record<string, StashMetadata>` — uses snake_case keys for Python interop
- Use `validateChangelistName()` and `sanitizeFilePath()` from changelistStore.ts for input validation
- Git operations: `src/gitUtils.ts` wraps all git commands via `child_process.execFile` (no shell)
- All gitUtils functions take `gitRoot` as parameter — pass result of `getGitRoot()`
- `getGitStatus()` returns `Map<string, string>` with path → 2-char status code (porcelain format)
- SCM provider: `ChangelistSCMProvider` (src/scmProvider.ts) manages the Source Control sidebar tree
- SCM groups ordered: [active changelists] → Unassigned → [stashed changelists]
- Groups are rebuilt when changelist set changes; resource states updated on every refresh
- Diff on click uses custom `git-cl-head` URI scheme via `HeadContentProvider` (shows `git show HEAD:path`)
- File watchers on `.git/cl.json`, `.git/cl-stashes.json`, `.git/index` + workspace file saves trigger debounced refresh (300ms)
- `activate()` in extension.ts is async — resolves gitRoot before creating SCM provider
- File decorations: `ChangelistDecorationProvider` in scmProvider.ts provides status badge letters + colors via `FileDecorationProvider` API
- `statusToDecoration()` maps 2-char git status codes to `FileDecoration` (badge letter, tooltip, ThemeColor)
- Use `vscode.window.registerFileDecorationProvider()` — fires `onDidChangeFileDecorations(undefined)` to refresh all decorations
- Missing-file detection uses `fs.existsSync()` for files in changelists not marked as git-deleted
- `dist/` is in `.gitignore` — don't try to `git add` build output
- SCM context menu args: first arg = clicked resource, second arg = array of all selected (multi-select)
- Command palette invocations get no args — detect and show file picker fallback
- `when` clause: `scmProvider == git` for built-in Git; `scmProvider == git-cl` for ours
- `validateChangelistName()` signature matches `showInputBox({ validateInput })` — returns `string | null`
- SCM group header commands: use `scm/resourceGroup/context` menu; first arg = `SourceControlResourceGroup` (has `.id`)
- Group ID convention: `cl:<name>` for active changelists, `stash:<name>` for stashed, `unassigned` for unassigned
- SCM input box access: `scmProvider.getSourceControl().inputBox.value` — prefer over always prompting for commit messages
- Inline button ordering: `inline@1` (stage), `inline@2` (unstage), `inline@3` (commit), `inline@9` (delete)
- Context menu ordering: `1_modification@1` (stage), `1_modification@2` (unstage), `1_modification@3` (commit), `1_modification@4` (delete)
- Stash group IDs: `stash:<name>` prefix; use `resolveStashName()` to extract name
- Must remove from stash store BEFORE adding files to changelist store during unstash (avoids stash conflict check)
- Find stash ref by message via `findStashRefByMessage()` — stash indices shift, message is stable
- Branch existence check: `gitBranchExists()` uses `git rev-parse --verify refs/heads/<name>`
- `gitCheckoutExistingBranch()` switches to an existing branch (vs `gitCheckoutBranch()` which creates new)
- Inline file buttons: `scm/resourceState/context` with `group: "inline@N"` — commands MUST have `icon` property
- File inline button ordering: `inline@1` (Open Diff), `inline@2` (Remove from CL)

## 2026-02-19 - US-001
- What was implemented: Full VS Code extension scaffold with build tooling
- Files changed:
  - `package.json` — Extension manifest with contributes, activationEvents, engines, scripts
  - `tsconfig.json` — TypeScript config targeting ES2020 with strict mode
  - `src/extension.ts` — Extension entry point with activate/deactivate
  - `.vscode/launch.json` — F5 Extension Development Host launch config
  - `.vscode/tasks.json` — Default build task for esbuild
  - `.gitignore` — Ignores node_modules, dist, .vsix, .venv
  - `.vscodeignore` — Excludes source/dev files from packaged extension
  - `.npmrc` — pnpm build approval config for esbuild
  - `pnpm-lock.yaml` — Lock file
- **Learnings for future iterations:**
  - npm is broken on this system; use `pnpm` for all package management
  - pnpm 10.x requires explicit approval for package build scripts via `.npmrc`
  - git init and git commands need `dangerouslyDisableSandbox: true` due to sandbox restrictions on `.git/`
  - The project CWD is `.chief/prds/main` but source code goes in `/home/satya/oss/git-cl-vscode/`
  - esbuild is configured inline in `package.json` scripts (no separate config file needed)
---

## 2026-02-19 - US-002
- What was implemented: Core data model for changelist storage
  - `ChangelistStore` class — loads/saves `.git/cl.json`, enforces single-ownership of files across changelists
  - `StashStore` class — loads/saves `.git/cl-stashes.json` with full stash metadata
  - `validateChangelistName()` — alphanumeric + hyphens/underscores/dots, max 100 chars, rejects git reserved words
  - `sanitizeFilePath()` — validates relative paths, rejects traversal/absolute/unsafe chars
  - Stash conflict check: files in stashed changelists cannot be added to active changelists
  - Empty changelists omitted on save (matches Python git-cl behavior)
- Files changed:
  - `src/changelistStore.ts` — ChangelistStore class, name validation, path sanitization
  - `src/stashStore.ts` — StashStore class, stash metadata types, type guards
- **Learnings for future iterations:**
  - Data format uses snake_case keys (e.g., `stash_ref`, `source_branch`, `file_categories`) to match Python git-cl interop
  - `cl.json` is a simple `Record<string, string[]>` — changelist name → relative file paths
  - `cl-stashes.json` maps changelist name → `StashMetadata` with `stash_ref`, `stash_message`, `files`, `timestamp`, `source_branch`, `file_categories`
  - File paths in cl.json use forward slashes (git convention) regardless of OS
  - Build (`pnpm run build`) needs `dangerouslyDisableSandbox: true` due to write to `dist/`
---

## 2026-02-19 - US-003
- What was implemented: Git utility layer wrapping common git operations
  - `getGitRoot(cwd)` — returns absolute path to repository root
  - `getGitStatus(gitRoot)` — runs `git status --porcelain`, returns `Map<string, string>` (path → 2-char status)
  - `gitAdd(files, gitRoot)` — stages specified files
  - `gitReset(files, gitRoot)` — unstages files (git reset HEAD)
  - `gitCheckout(files, gitRoot)` — reverts files to HEAD
  - `gitCommit(files, message, gitRoot)` — stages and commits files with message
  - `gitDiff(files, gitRoot, options?)` — returns diff output, supports `--staged`
  - `gitStashPush(message, gitRoot, files?)` — creates stash with optional file filtering
  - `gitStashPop(ref, gitRoot)` — pops a specific stash reference
  - `gitStashList(gitRoot)` — lists stash entries with refs and messages
  - `getCurrentBranch(gitRoot)` — returns branch name or null if detached
  - `gitCheckoutBranch(name, gitRoot, base?)` — creates and switches to new branch
- Files changed:
  - `src/gitUtils.ts` — All git utility functions, uses `child_process.execFile` for safety
- **Learnings for future iterations:**
  - All git operations use `execFile` (not `exec`) to avoid shell injection
  - `git status --porcelain` format: first 2 chars are status code, char 3 is space, rest is file path
  - Renamed files appear as `R  old -> new` — parser extracts the new path
  - `git symbolic-ref --short HEAD` fails in detached HEAD state — catch and return null
  - `gitStashList` returns empty array on error (e.g., no stash entries) rather than throwing
  - Private `execGit` helper centralizes error handling with 10MB max buffer
---

## 2026-02-19 - US-004
- What was implemented: SCM Provider & Changelist Tree View
  - `ChangelistSCMProvider` class — registers `vscode.scm.createSourceControl`, manages resource groups
  - `HeadContentProvider` — `TextDocumentContentProvider` for `git-cl-head` scheme, returns `git show HEAD:path`
  - Active changelist groups: one `SourceControlResourceGroup` per changelist from cl.json
  - Unassigned group: shows git-tracked files not in any changelist or stash
  - Stashed groups: read-only, labeled with changelist name, source branch, and timestamp
  - Diff on click: clicking a file opens `vscode.diff(headUri, workingUri)` for tracked files, `vscode.open` for untracked
  - Auto-refresh: watchers on `.git/cl.json`, `.git/cl-stashes.json`, `.git/index`, plus workspace file saves
  - Debounced refresh (300ms) to avoid excessive updates
  - Group ordering maintained: active changelists → Unassigned → stashed changelists
  - Updated `extension.ts` to async `activate()` that resolves gitRoot and creates the SCM provider
- Files changed:
  - `src/scmProvider.ts` — New file: ChangelistSCMProvider, HeadContentProvider
  - `src/extension.ts` — Updated: async activate, SCM provider initialization
- **Learnings for future iterations:**
  - VS Code SCM resource groups appear in creation order — dispose and recreate all groups when the set changes to maintain ordering
  - `SourceControlResourceGroup.hideWhenEmpty` hides groups with no resource states
  - For diff, use a custom URI scheme with `TextDocumentContentProvider` rather than depending on the built-in git extension's internals
  - Untracked files (`??` status) have no HEAD version — use `vscode.open` instead of `vscode.diff`
  - `SourceControlResourceState.decorations.faded` is useful for stashed/read-only files
  - `SourceControlResourceState.decorations.strikeThrough` marks deleted files
---

## 2026-02-19 - US-005
- What was implemented: File status decorations for changelist tree items
  - `ChangelistDecorationProvider` — implements `FileDecorationProvider`, provides status badge letters (M/A/D/U/R/C/!) and theme colors
  - `statusToDecoration()` — maps 2-char git porcelain status codes to `FileDecoration` with appropriate badge and color
  - Missing-file detection: files in changelists that no longer exist on disk get a `!` badge, strikethrough, and warning icon
  - `createResourceState()` enhanced: checks `fs.existsSync()`, uses `ThemeIcon('warning')` for missing files
  - Decoration provider fires `onDidChangeFileDecorations` on every SCM refresh cycle
  - Color scheme uses VS Code standard theme colors: `gitDecoration.modifiedResourceForeground`, `.addedResourceForeground`, `.deletedResourceForeground`, `.untrackedResourceForeground`, `.conflictingResourceForeground`
- Files changed:
  - `src/scmProvider.ts` — Added ChangelistDecorationProvider, statusToDecoration, enhanced createResourceState
- **Learnings for future iterations:**
  - `FileDecorationProvider` is the standard way to add badge letters and colors to any view (Explorer, SCM, etc.)
  - `vscode.FileDecoration(badge, tooltip, color)` — badge is 1-2 chars, color is a ThemeColor
  - Fire `onDidChangeFileDecorations(undefined)` to refresh all URIs (simpler than tracking individual changes)
  - `SourceControlResourceDecorations.iconPath` accepts `ThemeIcon` — useful for warning/error indicators
  - `dist/` is gitignored — only commit source files, not build output
  - Conflict detection: UU, AA, DD, AU, UA, DU, UD status codes all indicate merge conflicts
---

## 2026-02-19 - US-006
- What was implemented: Add Files to Changelist command with context menu and command palette support
  - `git-cl.addToChangelist` command registered in command palette and context menus
  - Context menu "Add to Changelist" on built-in Git SCM files (`scmProvider == git`)
  - Context menu "Add to Changelist" on Unassigned group files (`scmProvider == git-cl && scmResourceGroup == unassigned`)
  - Multi-select support: extracts file paths from second arg (array of selected resources)
  - Command palette mode: shows QuickPick with all modified/untracked files from git status for multi-select
  - `pickChangelist()`: QuickPick with existing changelists + "Create New Changelist" option that shows InputBox
  - InputBox validates name via `validateChangelistName()` inline
  - Files silently moved between changelists (handled by `ChangelistStore.addFiles()`)
  - Tree view refreshes immediately after adding via `scmProvider.refresh()`
  - Added `getGitRoot()` getter to `ChangelistSCMProvider`
- Files changed:
  - `package.json` — Added `git-cl.addToChangelist` command + `scm/resourceState/context` menu contributions
  - `src/extension.ts` — Command handler, `resolveFilePaths()`, `pickChangelist()` helper functions
  - `src/scmProvider.ts` — Added `getGitRoot()` public getter
- **Learnings for future iterations:**
  - SCM context menu args: first arg = clicked resource, second arg = array of all selected resources (multi-select)
  - `scm/resourceState/context` menu needs separate entries for each `scmProvider` (git vs git-cl)
  - `when` clause for built-in Git SCM: `scmProvider == git`; for our SCM: `scmProvider == git-cl`
  - `validateChangelistName()` returns `string | null` — compatible with `showInputBox({ validateInput })` API
  - For command palette invocations (no args), show file picker from `getGitStatus()` with `canPickMany: true`
---

## 2026-02-19 - US-007
- What was implemented: Remove Files from Changelist command with context menu and command palette support
  - `git-cl.removeFromChangelist` command registered in command palette and context menus
  - Context menu "Remove from Changelist" on files inside active changelist groups (`scmResourceGroup =~ /^cl:/`)
  - Multi-select support: handles array of selected resources from second arg
  - Command palette mode: shows QuickPick with all files from all changelists, grouped by changelist name
  - Uses `ChangelistStore.findChangelist()` to determine which changelist each file belongs to, then `removeFiles()` to remove
  - Files return to the "Unassigned" group after removal
  - Tree view refreshes immediately after removing via `scmProvider.refresh()`
- Files changed:
  - `package.json` — Added `git-cl.removeFromChangelist` command + `scm/resourceState/context` menu entry
  - `src/extension.ts` — Command handler + `resolveFilePathsFromChangelists()` helper function
- **Learnings for future iterations:**
  - Use `scmResourceGroup =~ /^cl:/` in `when` clause to match active changelist groups (IDs are `cl:<name>`)
  - VS Code `when` clauses support regex via `=~` operator — useful for matching dynamic group IDs
  - `ChangelistStore.findChangelist(path)` looks up which changelist owns a file — useful for removal without needing group context
  - Command palette removal shows files with their changelist name as description, helping users identify which list a file belongs to
---

## 2026-02-19 - US-008
- What was implemented: Delete Changelist commands with inline button and confirmation
  - `git-cl.deleteChangelist` command — deletes a single changelist with confirmation prompt
  - `git-cl.deleteAllChangelists` command — deletes all changelists with confirmation prompt
  - Inline trash icon button on changelist group headers via `scm/resourceGroup/context` menu
  - Context menu "Delete Changelist" entry on group headers
  - Command palette flow: QuickPick to select changelist, then confirmation dialog
  - Confirmation shows file count (e.g., "3 file(s) will be moved to Unassigned")
  - `resolveChangelistName()` extracts changelist name from group ID (strips `cl:` prefix)
  - Tree view refreshes immediately after deletion
- Files changed:
  - `package.json` — Added `git-cl.deleteChangelist` + `git-cl.deleteAllChangelists` commands, `scm/resourceGroup/context` menu entries
  - `src/extension.ts` — Command handlers, `resolveChangelistName()`, `pickChangelistForDeletion()`, `deleteChangelistWithConfirmation()` helpers
- **Learnings for future iterations:**
  - `scm/resourceGroup/context` menu is for group headers (vs `scm/resourceState/context` for file items)
  - Group header context menu args: first arg = `SourceControlResourceGroup` object (has `.id` property)
  - Use `group: "inline"` in menu contribution to show icon buttons on group headers
  - `ChangelistStore.deleteChangelist(name)` returns the removed files array (useful for undo if needed later)
  - `ChangelistStore.deleteAll()` clears all in-memory data; `save()` writes empty object to disk
---

## 2026-02-19 - US-009
- What was implemented: Stage Changelist command with inline button and command palette support
  - `git-cl.stageChangelist` command — stages all tracked files in a changelist
  - Inline stage button (`+` icon) on changelist group headers via `scm/resourceGroup/context` menu
  - Context menu "Stage Changelist" entry on group headers
  - Command palette flow: QuickPick to select changelist, then stage tracked files
  - Filters to tracked files only — untracked (`??`) files are skipped (matches git-cl behavior)
  - Shows notification if changelist is empty or has no tracked files
  - Refactored `pickChangelistForDeletion()` into generic `pickChangelistForAction(action)` for reuse
- Files changed:
  - `package.json` — Added `git-cl.stageChangelist` command + inline/context menu entries
  - `src/extension.ts` — Stage command handler, `pickChangelistForAction()` generic helper
- **Learnings for future iterations:**
  - Use `group: "inline@N"` to control ordering of inline buttons on group headers (lower N = further left)
  - `pickChangelistForAction(scmProvider, action)` is a generic QuickPick helper — reuse for stage, unstage, commit, diff, etc.
  - Tracked files = files in git status that are NOT `??` (untracked); filter before staging
  - `gitAdd()` from gitUtils.ts handles the actual `git add` operation
---

## 2026-02-19 - US-010
- What was implemented: Unstage Changelist command with inline button and command palette support
  - `git-cl.unstageChangelist` command — unstages all staged files in a changelist
  - Inline unstage button (`-` icon) on changelist group headers via `scm/resourceGroup/context` menu (inline@2)
  - Context menu "Unstage Changelist" entry on group headers (1_modification@2)
  - Command palette flow: QuickPick to select changelist, then unstage staged files
  - Filters to files with staged changes only — checks first char of porcelain status (non-space, non-?)
  - Shows notification if changelist is empty or has no staged files
  - Uses `gitReset()` from gitUtils.ts to execute `git reset HEAD --`
- Files changed:
  - `package.json` — Added `git-cl.unstageChangelist` command + inline/context menu entries
  - `src/extension.ts` — Unstage command handler, imported `gitReset`
- **Learnings for future iterations:**
  - Staged files detection: in `git status --porcelain`, first char (index status) is non-space and non-`?` for staged files
  - `gitReset()` from gitUtils.ts handles `git reset HEAD --` for unstaging
  - Inline button ordering: `inline@1` (stage), `inline@2` (unstage), `inline@9` (delete) — use gaps for future insertions
  - Context menu ordering: `1_modification@1` (stage), `1_modification@2` (unstage), `1_modification@3` (delete)
---

## 2026-02-19 - US-011
- What was implemented: Commit Changelist command with inline button and command palette support
  - `git-cl.commitChangelist` command — commits all tracked files in a changelist with a message
  - Inline commit button (`check` icon) on changelist group headers via `scm/resourceGroup/context` menu (inline@3)
  - Context menu "Commit Changelist" entry on group headers (1_modification@3)
  - Command palette flow: QuickPick to select changelist, then prompt for message
  - Commit message sourcing: uses SCM input box text if present, otherwise prompts via InputBox
  - Filters to tracked files only — untracked (`??`) files are skipped
  - Shows error if no tracked files or commit fails
  - Deletes changelist after successful commit (default behavior)
  - Clears SCM input box after successful commit
  - Success notification shows count of committed files
  - Uses `gitCommit()` from gitUtils.ts which stages then commits
- Files changed:
  - `package.json` — Added `git-cl.commitChangelist` command + inline/context menu entries
  - `src/extension.ts` — Commit command handler, imported `gitCommit`
- **Learnings for future iterations:**
  - `scmProvider.getSourceControl().inputBox.value` gives access to the SCM input box text — prefer this over always prompting
  - `gitCommit()` in gitUtils.ts handles both staging and committing in one call
  - Inline button ordering updated: `inline@1` (stage), `inline@2` (unstage), `inline@3` (commit), `inline@9` (delete)
  - Context menu ordering updated: `1_modification@1` (stage), `1_modification@2` (unstage), `1_modification@3` (commit), `1_modification@4` (delete)
---

## 2026-02-19 - US-012
- What was implemented: Diff Changelist command with context menu and command palette support
  - `git-cl.diffChangelist` command — opens diff tabs for all files in a changelist
  - Context menu "Diff Changelist" entry on changelist group headers (group `2_diff@1`)
  - Command palette flow: QuickPick to select changelist, then open diffs
  - For modified/staged files: opens `vscode.diff(HEAD, workingCopy)` showing all changes
  - For untracked files: opens file directly (no HEAD version exists)
  - For deleted files: opens HEAD version read-only
  - All tabs opened with `preview: false` so they stay open
  - Works correctly for files in subdirectories (uses relative paths with forward slashes)
- Files changed:
  - `package.json` — Added `git-cl.diffChangelist` command + `scm/resourceGroup/context` menu entry
  - `src/extension.ts` — Diff command handler using existing `pickChangelistForAction()` and `resolveChangelistName()`
- **Learnings for future iterations:**
  - VS Code `vscode.diff` command opens a diff editor tab — use `{ preview: false }` to prevent tab reuse
  - For multi-file diff, open each file's diff sequentially with `await` to ensure proper tab ordering
  - Deleted files can be shown read-only via the HEAD content provider (`git-cl-head` scheme)
  - Menu group `2_diff@1` separates diff actions from modification actions (`1_modification`) in context menus
  - The `$(diff)` codicon icon is available for diff-related commands
---

## 2026-02-19 - US-013
- What was implemented: Checkout (Revert) Changelist command
  - `git-cl.checkoutChangelist` command — reverts all files in a changelist to HEAD
  - Context menu "Checkout (Revert) Changelist" on changelist group headers (group `3_revert@1`)
  - Command palette flow: QuickPick to select changelist, then confirmation dialog
  - Confirmation dialog warns about data loss and shows file count
  - Two revert options: "Revert" (keep changelist) and "Revert & Delete Changelist" (remove changelist after revert)
  - Uses `gitCheckout()` from gitUtils.ts which runs `git checkout HEAD --`
  - Success notification shows count of reverted files
  - Tree view refreshes after revert
- Files changed:
  - `package.json` — Added `git-cl.checkoutChangelist` command + `scm/resourceGroup/context` menu entry
  - `src/extension.ts` — Checkout command handler, imported `gitCheckout`
- **Learnings for future iterations:**
  - `store.getFiles()` returns `readonly string[]` — spread into mutable array (`[...files]`) before passing to gitUtils functions that expect `string[]`
  - `$(discard)` codicon icon is appropriate for revert/checkout operations
  - Menu group `3_revert@1` separates destructive revert actions from diff (`2_diff`) and modification (`1_modification`) groups
  - `vscode.window.showWarningMessage` with `{ modal: true }` and multiple button labels is ideal for confirmation dialogs with options
---

## 2026-02-19 - US-014
- What was implemented: Changelist Status Display command
  - Replaced placeholder `showStatus` with full formatted status output
  - Shows active changelists with their files and ANSI-colored git status codes
  - Shows stashed changelists with timestamp and source branch info
  - Shows unassigned files (modified/staged/untracked not in any changelist or stash)
  - Summary line with counts of changelists, assigned files, unassigned files, stashes
  - Color scheme: green = added/untracked, yellow = modified/renamed, red = deleted/conflicts, cyan = changelist names, dim = clean/stashed
- Files changed:
  - `src/extension.ts` — Replaced placeholder showStatus handler with `showFormattedStatus()`, added `colorizeStatus()` helper and ANSI color constants
- **Learnings for future iterations:**
  - VS Code output channels support ANSI escape codes (`\x1b[32m` etc.) for colored text in recent versions
  - `outputChannel.clear()` clears previous content before writing fresh status
  - `outputChannel.show(true)` reveals the output channel without stealing focus (preservesFocus = true)
  - `ChangelistStore.getAll()` returns `Record<string, string[]>` — use `Object.keys()` and direct indexing for iteration
  - `StashStore.getStashedFiles()` returns a `Set<string>` of all files across all stashes — useful for excluding from unassigned
---

## 2026-02-19 - US-015
- What was implemented: Stash Changelist command with context menu and Stash All variant
  - `git-cl.stashChangelist` command — stashes a single changelist with full file categorization
  - `git-cl.stashAllChangelists` command — stashes all active changelists sequentially
  - Context menu "Stash Changelist" on changelist group headers (group `4_stash@1`)
  - Command palette flow: QuickPick to select changelist, then stash
  - File categorization: unstaged_changes, staged_additions, untracked, deleted (matching Python git-cl)
  - Stash message format: `git-cl-stash:<name>:<timestamp>` (ISO 8601)
  - Saves full `StashMetadata` to cl-stashes.json via `StashStore.setStash()`
  - Removes changelist from cl.json after successful stash
  - Rollback on failure: drops git stash or restores metadata if save fails
  - Shows error if no stashable files (all files are clean)
  - Updated `gitStashPush` to support `--include-untracked` for untracked files
  - Added `gitStashDrop` function for rollback support
- Files changed:
  - `package.json` — Added `git-cl.stashChangelist` + `git-cl.stashAllChangelists` commands, context menu entry
  - `src/extension.ts` — Stash command handlers, `stashSingleChangelist()` helper, imported stash-related functions
  - `src/gitUtils.ts` — Updated `gitStashPush` signature (added options.includeUntracked), added `gitStashDrop`
- **Learnings for future iterations:**
  - `git stash push --include-untracked -m <msg> -- <files>` handles all file types (staged, unstaged, untracked, deleted)
  - Only add `--include-untracked` when there are actually untracked files in the stash list
  - Stash ref is always `stash@{0}` immediately after creation — safe to use without searching
  - `getCurrentBranch()` returns null in detached HEAD state — fall back to `'HEAD'` for metadata
  - Rollback strategy: on metadata save failure → drop stash; on cl.json save failure → remove stash entry + pop stash
  - `StashStore.setStash(name, metadata)` adds/updates an entry; `StashStore.removeStash(name)` removes it
  - Menu group `4_stash@1` keeps stash action separate from modification, diff, and revert groups
  - `FileCategories` and `StashMetadata` types are exported from stashStore.ts for use in extension.ts
---

## 2026-02-19 - US-016
- What was implemented: Unstash Changelist command with branch/conflict validation
  - `git-cl.unstashChangelist` command — unstashes a changelist with branch and conflict validation
  - `git-cl.unstashChangelistForce` command — unstashes without branch/conflict checks (force mode)
  - `git-cl.unstashAllChangelists` command — unstashes all stashed changelists sequentially
  - Context menu "Unstash Changelist" on stashed changelist group headers (inline + context)
  - Context menu "Unstash Changelist (Force)" for skipping validation checks
  - Branch validation: warns if current branch differs from source branch where stash was created
  - Conflict detection: checks if stashed files have uncommitted changes in working tree, suggests workflow actions
  - Finds correct stash reference by matching stash message (handles shifted stash indices)
  - Executes `git stash pop` and restores changelist to cl.json
  - Order: removes from stash store first, then adds to changelist store (avoids stash conflict check)
  - Rollback: restores stash metadata if cl.json update fails
  - Tree view refreshes to show restored changelist in active section
- Files changed:
  - `package.json` — Added `git-cl.unstashChangelist`, `git-cl.unstashChangelistForce`, `git-cl.unstashAllChangelists` commands + inline/context menu entries for stashed groups
  - `src/extension.ts` — Unstash command handlers, `resolveStashName()`, `pickStashedChangelistForAction()`, `findStashRefByMessage()`, `unstashSingleChangelist()` helper functions; added `gitStashList` import
- **Learnings for future iterations:**
  - Stash group IDs use `stash:<name>` prefix — use `resolveStashName()` to extract name (strips `stash:` prefix)
  - `when` clause for stashed groups: `scmResourceGroup =~ /^stash:/`
  - Must remove from stash store BEFORE adding files to changelist store — `addFiles()` checks stash conflicts and would reject files still in stash
  - `findStashRefByMessage()` searches `gitStashList()` by message match, since stash indices shift when stashes are created/dropped
  - `gitStashList()` returns entries with `message` that includes the full stash line after first colon — use `includes()` for matching
  - Force mode (`--force` equivalent) skips branch and conflict validation entirely
---

## 2026-02-19 - US-017
- What was implemented: Branch from Changelist command
  - `git-cl.branchFromChangelist` command — creates a new branch with a changelist's changes isolated
  - Context menu "Branch from Changelist" on changelist group headers (group `5_branch@1`)
  - Command palette flow: QuickPick to select changelist, then prompts for branch name and base branch
  - Branch name defaults to changelist name; base branch defaults to current branch
  - Validates: changelist is non-empty, branch doesn't already exist, no unassigned uncommitted changes
  - Workflow: stashes all active changelists → creates branch → unstashes target changelist only
  - Full rollback on failure: unstashes all changelists and returns to original branch
  - Added `gitBranchExists()` and `gitCheckoutExistingBranch()` to gitUtils.ts
- Files changed:
  - `package.json` — Added `git-cl.branchFromChangelist` command + `scm/resourceGroup/context` menu entry
  - `src/extension.ts` — Branch command handler, imported new git utilities
  - `src/gitUtils.ts` — Added `gitBranchExists()` and `gitCheckoutExistingBranch()` functions
- **Learnings for future iterations:**
  - `git rev-parse --verify refs/heads/<name>` is the reliable way to check if a local branch exists
  - Branch name validation: reject `\s~^:?*[\` characters (git ref format rules)
  - Reuse existing `stashSingleChangelist()` and `unstashSingleChangelist()` for the stash-all/unstash-target workflow
  - Force mode (`true`) on unstash skips branch/conflict validation — needed during branch creation since we're on a new branch
  - Menu group `5_branch@1` keeps branch action separate from stash (`4_branch`), revert (`3_revert`), diff (`2_diff`), and modification (`1_modification`) groups
  - `$(git-branch)` codicon icon is appropriate for branch-related commands
---

## 2026-02-19 - US-018
- What was implemented: Context menus in built-in Changes section — already fully implemented in US-006
  - `scm/resourceState/context` menu entry with `when: "scmProvider == git"` (package.json line 190-193)
  - Multi-select support via `resolveFilePaths()` handling second arg as array of SourceControlResourceState
  - QuickPick to choose or create changelist via `pickChangelist()`
  - Path resolution from built-in Git SCM resource URIs via `path.relative(gitRoot, r.resourceUri.fsPath)`
  - Visibility controlled by `scmProvider == git` when clause (only present in git repos)
- Files changed: None (all criteria were already met from US-006)
- **Learnings for future iterations:**
  - US-018 was fully covered by US-006 implementation — the built-in Git SCM integration was done alongside the general "Add to Changelist" command
  - The built-in Git extension's `resourceUri` is always a `file://` URI, so `fsPath` gives the correct absolute path
  - `scmProvider == git` when clause automatically limits menu visibility to git repositories
---

## 2026-02-19 - US-019
- What was implemented: Inline action buttons on changelist file entries and group headers
  - Inline "Open Diff" (`$(diff)` icon) button on individual file entries in active changelists (`inline@1`)
  - Inline "Remove from Changelist" (`$(close)` icon) button on individual file entries in active changelists (`inline@2`)
  - New `git-cl.openFileDiff` command — opens diff (HEAD vs working tree) for a single file from inline button
  - Added icon to `removeFromChangelist` command definition for inline button rendering
  - Context menu "Open Diff" entry also added to file items in active changelists (`2_diff` group)
  - Pre-existing group header buttons: Stage (+), Unstage (-), Commit (check), Delete (trash) — already implemented in prior stories
  - Pre-existing stash group inline button: Unstash — already implemented in US-016
- Files changed:
  - `package.json` — Added `git-cl.openFileDiff` command, icon for `removeFromChangelist`, inline + context menu entries in `scm/resourceState/context`
  - `src/extension.ts` — Added `openFileDiff` command handler, registered in subscriptions
- **Learnings for future iterations:**
  - `scm/resourceState/context` with `group: "inline@N"` adds icon buttons next to individual file entries (same pattern as group headers)
  - Inline button ordering for files: `inline@1` (Open Diff), `inline@2` (Remove) — leftmost is lowest number
  - File inline buttons need separate entries from context menu entries (inline vs numbered group)
  - The `openFileDiff` command reuses the same diff logic as the resource state's click command (HEAD scheme + `vscode.diff`)
  - Commands used as inline buttons MUST have an `icon` property in their command definition, otherwise no button is shown
---

## 2026-02-19 - US-020
- What was implemented: File Watcher & Auto-Refresh — verified existing implementation and added HEAD file watching
  - FileSystemWatcher already monitors `.git/cl.json`, `.git/cl-stashes.json`, and `.git/index` (from US-004)
  - Added `.git/HEAD` to watched file patterns for robust branch switch detection
  - Debounced refresh at 300ms (well within the 500ms requirement) prevents excessive updates
  - `onDidSaveTextDocument` handler triggers refresh when files are saved (git status may change)
  - Branch switching triggers refresh via both `index` and `HEAD` file watchers
  - All acceptance criteria were already substantially met by US-004's implementation
- Files changed:
  - `src/scmProvider.ts` — Added `HEAD` to watched file patterns in `setupWatchers()`
- **Learnings for future iterations:**
  - Most of US-020 was already implemented in US-004 — the file watcher infrastructure was built alongside the SCM provider
  - `.git/HEAD` changes when switching branches (`git checkout`, `git switch`) — watching it provides an additional signal beyond the index watcher
  - VS Code's `files.watcherExclude` default excludes `.git/objects/**` and `.git/subtree-cache/**` but NOT files directly in `.git/` — so `cl.json`, `index`, `HEAD` are all watchable
  - `vscode.workspace.createFileSystemWatcher` with `RelativePattern(Uri.file(gitDir), filename)` correctly watches individual files inside `.git/`
  - Trailing-edge debounce pattern: clear + set timeout ensures only one refresh fires after rapid changes settle
---

## 2026-02-19 - US-021
- What was implemented: Unit tests for all three core modules (changelistStore, stashStore, gitUtils)
  - 102 tests total across 3 test files
  - `changelistStore.test.ts` (46 tests): validateChangelistName edge cases (empty, length, special chars, reserved words), sanitizeFilePath (traversal, absolute, unsafe chars), ChangelistStore CRUD (load, save, add, remove, create, delete, findChangelist), single-ownership enforcement, stash conflict checks, empty changelist omission, round-trip interop
  - `stashStore.test.ts` (21 tests): StashStore load/save, metadata validation (type guards for StashMetadata and FileCategories), getStashedFiles aggregation, snake_case key preservation for Python interop, round-trip save/load
  - `gitUtils.test.ts` (35 tests): All git utility functions mocked via vi.mock('child_process'), status parsing (porcelain format, renames, empty), gitAdd/Reset/Checkout/Commit arg validation, gitDiff staged flag, gitStash push/pop/drop/list, getCurrentBranch (normal + detached HEAD), branch operations
  - Installed vitest + @vitest/coverage-v8, created vitest.config.ts
  - Coverage: Statements 98.6%, Branches 94.57%, Functions 100%, Lines 98.55% (all well above 80% threshold)
- Files changed:
  - `package.json` — Updated test script to `vitest run`, added `test:coverage` script, added vitest + coverage devDependencies
  - `vitest.config.ts` — New: vitest config with coverage thresholds for core modules
  - `src/changelistStore.test.ts` — New: 46 unit tests for ChangelistStore, validateChangelistName, sanitizeFilePath
  - `src/stashStore.test.ts` — New: 21 unit tests for StashStore, metadata validation
  - `src/gitUtils.test.ts` — New: 35 unit tests for all gitUtils functions with child_process mocking
  - `pnpm-lock.yaml` — Updated with vitest dependencies
- **Learnings for future iterations:**
  - vitest works out of the box with TypeScript — no separate ts-node or tsconfig-for-tests needed
  - `vi.mock('child_process')` + `vi.mocked(execFile)` cleanly mocks the execFile callback pattern
  - ChangelistStore/StashStore tests use real filesystem (os.tmpdir temp dirs) for load/save coverage — more reliable than mocking fs
  - Coverage config in vitest.config.ts: use `include` array to scope coverage to specific source files (not test files)
  - `@vitest/coverage-v8` provides v8-based coverage — fast, no Istanbul transform needed
---

## 2026-02-19 - US-022
- What was implemented: Comprehensive error handling & user notifications
  - Fixed silent git status failure in `openFileDiffCmd` — now shows error notification with git error message
  - Added file-not-found warning notifications — proactively warns when files in changelists no longer exist on disk (debounced, only warns about newly missing files)
  - Fixed unhandled promise rejections in `debouncedRefresh()` and constructor's initial `refresh()` call — errors now logged to output channel
  - Added error logging for git status failures during background refresh — logged to output channel instead of silently swallowed
  - Wrapped post-commit and post-revert changelist save operations in try/catch — shows warning if commit/revert succeeded but data save failed
  - Passed `outputChannel` to `ChangelistSCMProvider` for structured error logging
  - All acceptance criteria verified:
    - AC1: All git command failures show error notifications ✓
    - AC2: Invalid changelist name shows descriptive error (already implemented) ✓
    - AC3: File-not-found warnings shown proactively ✓
    - AC4: Stash conflicts show actionable suggestions (already implemented) ✓
    - AC5: Network/permission errors caught gracefully ✓
    - AC6: No unhandled promise rejections ✓
- Files changed:
  - `src/scmProvider.ts` — Added outputChannel parameter, lastWarnedMissingFiles tracking, missing file warnings, promise rejection handling in debouncedRefresh/constructor, git status error logging
  - `src/extension.ts` — Passed outputChannel to SCM provider, fixed openFileDiffCmd error handling, wrapped post-commit/post-revert save operations in try/catch
- **Learnings for future iterations:**
  - `setTimeout(() => asyncFn(), delay)` creates unhandled promise rejections — always add `.catch()` to the promise
  - VS Code output channels (`vscode.OutputChannel`) are good for logging background errors that shouldn't interrupt the user with notifications
  - For file-not-found warnings, track "last warned" state to avoid spamming on every refresh cycle
  - Post-operation save failures (e.g., commit succeeded but changelist deletion failed) deserve `showWarningMessage` not `showErrorMessage` — the primary operation succeeded
---
